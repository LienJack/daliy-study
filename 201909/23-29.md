# 2019.09.23
# 2019.09.26
研究react渲染逻辑源码  
思考知识库的框架
# 2019.09.27
开启博客2.0
# 2019.09.28
极客时间
[x] 01 | Chrome架构：仅仅打开了1个页面，为什么有4个进程？
[x] 02 | TCP协议：如何保证页面文件能被完整送达浏览器？
[x] 03 | HTTP请求流程：为什么很多站点第二次打开速度会很快？
[x] 04 | 导航流程：从输入URL到页面展示，这中间发生了什么？
[x] 05 | 渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面的？
[x] 06 | 渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面的？
[x] 07 | 变量提升：JavaScript代码是按顺序执行的吗？
[x] 08 | 调用栈：为什么JavaScript代码会出现栈溢出？
[x] 09 | 块级作用域：var缺陷以及为什么要引入let和const？
[x] 10 | 作用域链和闭包 ：代码中出现相同的变量，JavaScript引擎是如何选择的？
[x] 11 | this：从JavaScript执行上下文的视角讲清楚this
[x] 12 | 栈空间和堆空间：数据是如何存储的？
# 2019.09.29
[x] 13 | 垃圾回收：垃圾数据是如何自动回收的？
[x] 14 | 编译器和解释器：V8是如何执行一段JavaScript代码的？
[x] 15 | 消息队列和事件循环：页面是怎么“活”起来的？
[x] 16 | WebAPI：setTimeout是如何实现的？
[x] 17 | WebAPI：XMLHttpRequest是怎么实现的？
[x] 18 | 宏任务和微任务：不是所有任务都是一个待遇
[x] 19 | Promise：使用Promise，告别回调函数
[x] 20 | async/await：使用同步的方式去写异步代码
[x] 21 | Chrome开发者工具：利用网络面板做性能分析
[x] 22 | DOM树：JavaScript是如何影响DOM树构建的？
