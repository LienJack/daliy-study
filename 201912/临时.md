# 2019.12.03

## 中序遍历
递归
```javascript
function inorderTraversal(root, arr = []) {
  // debugger
  if (root) {
    inorderTraversal(root.left, arr)
    arr.push(root.value)
    inorderTraversal(root.right, arr)
  }
  return arr
}
```

非递归
```javascript
function inorderTraversalV2(root) {
  let stack = []
  let res = []
  let cur = root
  while (cur || stack.length > 0) {
    while (cur) {
      stack.push(cur)
      cur = cur.left
    }
    cur = stack.pop()
    res.push(cur.value)
    cur = cur.right
  } 
  return res
}
```

## 先序遍历
递归
```javascript
function preorderTraversal(root, arr = []) {
  if (root) {
    arr.push(root.value) 
    preorderTraversal(root.left, arr)
    preorderTraversal(root.right, arr)
    return arr
  }
}
```

非递归
```javascript
function preorderTraversal(root, arr = []) { 
  const result = []
  const stack = []
  let current = root
  while(current || stack.length > 0) {
    while (current) {
      result.push(current.value)
      stack.push(current)
      current = current.left
    }
    current = stack.pop()
    current = current.right
  }
  return result
}
```

## 后续遍历
递归
```javascript
function postorderTraversal(root, arr) {
  if (root) {
    postorderTraversal(root.left, arr)
    postorderTraversal(root.right, arr)
    array.push(root.value)
  }
}
```

## 101. 对称二叉树

给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```
但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:
```
    1
   / \
  2   2
   \   \
   3    3
```

### 思路
二叉树的右子树是二叉树左子树的镜像二叉树。

镜像二叉树：两颗二叉树根结点相同，但他们的左右两个子节点交换了位置。
![image](http://www.conardli.top/docs/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.png)

如图，1为对称二叉树，2、3都不是。

两个根结点相等
左子树的右节点和右子树的左节点相同。
右子树的左节点和左子树的右节点相同。
递归所有节点满足以上条件即二叉树对称。

### 代码
```javascript
var isSymmetric = function(root) {
  if (!root) return true
    return isSymmetricalTree(root.left, root.right)
  };
  
  function isSymmetricalTree (node1, node2) {
    // 判断是否同样没有
    if (!node1 && !node2) {
      return true
    }
    // 判断是否单个没有
    if (!node1 || !node2) {
      return false
    }
    if (node1.val != node2.val) {
      return false
    }
    return isSymmetricalTree(node1.left, node2.right) && isSymmetricalTree(node1.right, node2.left)
  }
```

## 105. 从前序与中序遍历序列构造二叉树
根据一棵树的前序遍历与中序遍历构造二叉树。

```
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
```
返回如下的二叉树：
```
    3
   / \
  9  20
    /  \
   15   7
```

### 思路
- 前序遍历：跟节点 + 左子树前序遍历 + 右子树前序遍历
- 中序遍历：左子树中序遍历 + 跟节点 + 右字数中序遍历
- 后序遍历：左子树后序遍历 + 右子树后序遍历 + 跟节点
根据上面的规律：
- 前序遍历找到根结点root
- 找到root在中序遍历的位置 -> 左子树的长度和右子树的长度
- 截取左子树的中序遍历、右子树的中序遍历
- 截取左子树的前序遍历、右子树的前序遍历
- 递归重建二叉树

![image](http://www.conardli.top/docs/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.png)
### 代码
```javascript
   function reConstructBinaryTree(pre, vin) {
        if(pre.length === 0){
            return null;
        }
        if(pre.length === 1){
            return new TreeNode(pre[0]);
        }
        const value = pre[0];
        const index = vin.indexOf(value);
        const vinLeft = vin.slice(0,index);
        const vinRight = vin.slice(index+1);
        const preLeft = pre.slice(1,index+1);
        const preRight = pre.slice(index+1);
        const node = new TreeNode(value);
        node.left = reConstructBinaryTree(preLeft, vinLeft);
        node.right = reConstructBinaryTree(preRight, vinRight);
        return node;
    }
```

## 226. 翻转二叉树
翻转一棵二叉树。
示例：
输入：
```
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```
输出：
```
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```
### 解题
```javascript
var invertTree = function(root) {
    if (root) {
      const temp = root.right
      root.right = root.left
      root.left = temp
      invertTree(root.right)
      invertTree(root.left)
    }
    return root
};
```

