# 2019.12.02
## 141. 环形链表

给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```
![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```
![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

### 思路
双指针

思路

想象一下，两名运动员以不同的速度在环形赛道上跑步会发生什么？

算法

通过使用具有 不同速度 的快、慢两个指针遍历链表，空间复杂度可以被降低至 O(1)O(1)。慢指针每次移动一步，而快指针每次移动两步。

如果列表中不存在环，最终快指针将会最先到达尾部，此时我们可以返回 false。

现在考虑一个环形链表，把慢指针和快指针想象成两个在环形赛道上跑步的运动员（分别称之为慢跑者与快跑者）。而快跑者最终一定会追上慢跑者。这是为什么呢？考虑下面这种情况（记作情况 A）- 假如快跑者只落后慢跑者一步，在下一次迭代中，它们就会分别跑了一步或两步并相遇。

其他情况又会怎样呢？例如，我们没有考虑快跑者在慢跑者之后两步或三步的情况。但其实不难想到，因为在下一次或者下下次迭代后，又会变成上面提到的情况 A。

### 解题
```javascript
var hasCycle = function(head) {

    if(head === null || head.next === null) return false;
    var slow = head;
    var fast = head.next;
    while (slow != fast){
        if (fast === null || fast.next === null) return false;
        slow = slow.next;
        fast = fast.next.next;
    }
    return true;
};
```

## 题目 142. 环形链表 II (链表环形入口节点 )

给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null

### 思路
声明两个指针 P1 P2

1. 判断链表是否有环： P1 P2 从头部出发，P1走两步，P2走一步，如果可以相遇，则环存在

2. 从环内某个节点开始计数，再回到此节点时得到链表环的长度 length

3. P1、P2 回到head节点，让 P1 先走 length 步 ，当P2和P1相遇时即为链表环的起点

![image](http://www.conardli.top/docs/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9.png)

### 解题
```javascript
function  EntryNodeOfLoop (pHead) {
  if(!pHead || !pHead.next) {
    return null
  }
  let p1 = pHead.next
  let p2 = pHead.next.next
  while (p1 != p2) {
    if (p2 === null || p2.next === null) {
      return null
    }
    p1 = p1.next
    p2 = p2.next.next
  }
  let temp = p1
  let length = 1
  p1 = p1.next
  while (temp !=p1) {
    p1 = p1.next
    length++
  }
  p1 = p2 = pHead
  while (length -- > 0) {
    p2 = p2.next
  }
  while (p1 != p2) {
    p1 = p1.next
    p2 = p2.next
  }
  return p1
}
```


## 题目 约瑟夫环

0,1,...,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。

其实这就是著名的约瑟夫环问题，下面是这个问题产生的背景，一个有趣的故事：

> 据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是，给定了和，一开始要站在什么地方才能避免被处决？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。

### 思路

用链表模拟环


- 用链表模拟一个环

- 模拟游戏场景

- 记录头节点的前一个节点current，以保证我们找到的要删除的节点是current.next

- 每次循环m次找到目标节点删除，直到链表只剩下一个节点

- 时间复杂度O(m*n) 空间复杂度O(n)

### 解题
``` javascript
function LastRemaining (n,m) {
  if (n < 1 || m < 1) {
    return -1;
  }
  let head = {
    val: 0,
    next: null
  }
  // 先弄一个环
  let cur = head
  for (let i =1; i < n; i++) {
    cur.next = { val: i, next: null }
    cur = cur.next
  }
  cur.next = head
  //  开始除去
  while (cur.next !== cur) {
    for (let i = 0; i < m - 1; i ++) {
      cur = cur.next
    }
    cur.next = cur.next.next
  }
  return cur.val
}
```








