# 2019.08.19
## 极客时间web协议
**架构原则**
- 性能影响可用的关键
- 课伸缩性 支持部署大量组件
- 简单性 易理解、易实现、易验证
- 可见性 两个组件间交互进行相互监视
- 可移植性 不同环境运行的能力
- 可靠性 出现故障时， 对整体影响程度
- 可修改性 对系统修改的难度

性能：  
- 网络性能
  - 吞吐量，小于宽带
  - 开销
- 用户感知的性能
  - 延迟： 发起请求到接受响应的时间
  - 完成时间： 完成一个应用所花费的时间
- 网络效率
  - 重用缓存、减少交互次数

课修改性：
- 可进化性： 一个组件单独升级不影响其他组件
- 可扩展： 想系统添加功能而不影响系统其他部分
- 可制定性： 临时、制定性更改某一个要素来提供服务
- 可配置性： 应用部署后修改配置提供新的功能
- 可重用性： 组件可不修改在其他应用使用

5 种架构风格
- 数据流风格：
  - 简单性、可进化性、可扩展性、可配置
  - ![image](./img/01.jpg)
- 复制风格
  - 用户可察觉性、可扩展性、可伸缩性、网络效率、可靠性
  - ![image](./img/02.jpg)
- 分层性
  - 简单性、可进化性、可伸缩性
  - ![image](./img/03.jpg)
- 移动代码风格
  - 可移植性、可扩展性、网络效率
- 点对

过滤器：
- domain 域名
- method 方法
- mime-type 显示MIME资源
## 每天一题
### 第 53 题：输出以下代码的执行结果并解释为什么
```javascript
var a = {n: 1};
var b = a;
a.x = a = {n: 2};

console.log(a.x) 	
console.log(b.x)
```
最后输出的是什么？ 先不说答案，我们来分析一下
L2(第二行) 我们把a赋值给b， 由于a是对象类型，这就意味着b和a指向同一个内存地址
L3 a.x = a = { n: 2}
这里我们有个疑惑，这句语句执行顺序是 a = {n: 2} && a.x = {n:2} 还是 a.x = {n:2} && a= {n:2} 还是这种 a = {n: 2} && a.x = a
我们这里可以借助 Object.defineProperty 或 ES6的 Proxy来验证多项赋值的顺序是怎样的
```javascript
const obj = new Proxy({}, {
  set(target, key, value, r) {
    console.log(key, value)
    if (key === 'a') Reflect.set(target, key, 'isA', r);
    else Reflect.set(target, key, value, r);
  }
});

obj.b = obj.a= {n: 1};
// 输出:
// "a" {n: 1}
// "b" {n: 1}

obj.a; // isA
obj.b; // {n: 1}

```
所以我们可以得出 赋值的顺序是从右边开始到左边的。而且是直接 a = {n: 1}, a.x = {n:1 }，而不是 a.x = a 这样去赋值
现在我们再借助 Proxy 来分析一开始part1这道题，用obj.a, obj.b 来代替原题目的 a和b。
```javascript
var obj = new Proxy({}, {
  get: function (target, key, receiver) {
    console.log(`getting ${key}!`);
    return Reflect.get(target, key, receiver);
  },
  set: function (target, key, value, receiver) {
    console.log(`setting ${key}!`);
    return Reflect.set(target, key, value, receiver);
  }
});

obj.a = {n: 1 };// getting a;
obj.b = obj.a; // getting a; setting b;
obj.a.x = obj.a = {n:2 }; // getting a; setting a;
```
可以看到 obj.a.x = obj.a = {n: 2}这段语句执行时，会先输出一个 getting a 再输出 setting a。   
这就意味着在对 obj.a.x 赋值时，程序是先获取 obj.a指向的对象的内存地址，此时触发了 getting a，然后再对右边 obj.a 进行赋值，触发了 setting a， 赋值完最后一步才是对 obj.a.x赋值 {n:2 }。
重点: 在对obj.a.x赋值的时刻已经获取了obj.a该对象指向的内存地址，所以后面a就算指向其他地址，也和这里的obj.a.x无关。此时指向该地址的还有obj.b
我们再用三张图来捋一捋整理的思路
执行 obj.a = {n: 1}; obj.b = obj.a后obj对应的引用是这样的
![image](https://user-gold-cdn.xitu.io/2018/7/31/164f04a4246bb7b6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
执行 obj.a.x = xxx 时 
![image](https://user-gold-cdn.xitu.io/2018/7/31/164f04a61979d4ac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
执行obj.a.x = obj.a = {n:2} 后 
![image](https://user-gold-cdn.xitu.io/2018/7/31/164f04a73739a877?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
至此，这道面试题相信大家都有答案了，可以自己去控制台验证一下。 假如这时候再执行 obj.a.n = 3， 打印obj.b会输出什么呢？

### 第 54 题：冒泡排序如何实现，时间复杂度是多少， 还可以如何改进？
默认
```javascript
function bubleSort(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr.length - 1 -1; j++) {
      if (arr[j] > arr[j+1]) {
        [arr[i], arr[j]] 
      }
    }
  }
}
```

```javascript
function bubleSort(arr) {
  let i = arr.length - 1
  while (i>0) {
    let pos = 0
    for (let j = 0; j< i;)
  }
}
```
# 2019.08.20