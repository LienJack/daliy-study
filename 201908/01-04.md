# 2019.08.01

[x] 二叉树结构
[x] 最小堆  
[x] 最大堆

## 数据结构

### BinaryTree

```javascript
class TreeNode {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}
class BinaryTree {
  constructor(arr) {
    this.root = null;
    const treeNodeArr = arr.map(item => {
      return new TreeNode(item);
    });
    treeNodeArr.unshift(null);
    for (let i = 1; i <= Math.floor(arr.length / 2); i++) {
      if (treeNodeArr[i * 2] && treeNodeArr[i].left === null) {
        treeNodeArr[i].left = treeNodeArr[i * 2];
      }
      if (treeNodeArr[i * 2 + 1] && treeNodeArr[i].right === null) {
        treeNodeArr[i].right = treeNodeArr[i * 2 + 1];
      }
    }
    this.root = treeNodeArr[1];
  }
  inOrder(cb) {
    this._inOrder(this.root, cb);
  }
  _inOrder(node, cb) {
    if (node !== null) {
      this._inOrder(node.left, cb);
      cb(node.value);
      this._inOrder(node.right, cb);
    }
  }
  print() {
    this.inOrder(val => console.log(val));
  }
}
```

### MinHeap

```javascript
class MinHeap {
  constructor(arr) {
    this.heap = [null];
    arr.forEach(item => {
      this.insert(item);
    });
  }
  peak() {
    return this.heap[i];
  }
  len() {
    return this.heap.length - 1;
  }
  insert(num) {
    const heap = this.heap;
    heap.push(num);
    const heapLength = heap.length;
    if (heapLength <= 2) {
      return;
    }
    let id = heapLength - 1;
    let parentId = Math.floor(id / 2);
    while (parentId && heap[id] < heap[parentId]) {
      [heap[id], heap[parentId]] = [heap[parentId], heap[id]];
      id = parentId;
      parentId = Math.floor(id / 2);
    }
  }
  remove() {
    const heap = this.heap;
    if (heap.length <= 1) return;
    if (heap.length <= 2) return heap.pop();
    const last = heap.pop();
    let i = 1;
    const smallest = heap[i];
    heap[i] = last;
    let leftId = i * 2;
    let rightId = i * 2 + 1;
    while (
      (heap[leftId] !== undefined && heap[i] > heap[leftId]) ||
      (heap[rightId] !== undefined && heap[i] > heap[rightId])
    ) {
      if (heap[rightId] !== undefined && heap[rightId] < heap[leftId]) {
        [heap[i], heap[rightId]] = [heap[rightId], heap[i]];
        i = rightId;
      } else {
        [heap[i], heap[leftId]] = [heap[leftId], heap[i]];
        i = leftId;
      }
      leftId = i * 2;
      rightId = i * 2 + 1;
    }
    return smallest;
  }
}
```

### MaxHeap

```javascript
MaxHeap {
  constructor(arr) {
    this.heap = [null]
    arr.forEach(item => {
      this.insert(item)
    })
  }
  peak () {
    return this.heap[i]
  }
  len () {
    return this.heap.length - 1
  }
  insert(num) {
    const heap = this.heap
    heap.push(num)
    const heapLength = heap.length
    if (heapLength <= 2) {
      return
    }
    let id = heapLength - 1
    let parentId = Math.floor(id/2)
    while (parentId && heap[id] > heap[parentId]) {
      [heap[id], heap[parentId]] = [heap[parentId], heap[id]]
      id = parentId
      parentId = Math.floor(id/2)
    }
  }
  remove() {
    const heap = this.heap
    if (heap.length <= 1) return
    if (heap.length <=2) return this.heap.pop()
    const last = heap.pop()
    let i = 1
    const maxest = heap[i]
    heap[i] = last
    let leftId = i * 2
    let rightId = i * 2 + 1
    while((heap[leftId] !== undefined && heap[i] < heap[leftId]) || (heap[rightId]) !== undefined && heap[i] < heap[rightId]) {
      if (heap[rightId] !== undefined && heap[rightId] > heap[leftId]) {
        [heap[i], heap[rightId]] = [heap[rightId], heap[i]]
        i = rightId
      } else {
        [heap[i], heap[leftId]] = [heap[leftId], heap[i]]
        i = leftId
      }
      leftId = i * 2
      rightId = i * 2 + 1
    }
    return maxest
  }
}
```

## 每日一题

### 第 5 题：介绍下深度优先遍历和广度优先遍历，如何实现？

深度优先

```javascript
let deepTraversal = (node, nodeList = []) => {
  if (node !== null) {
    nodeList.push(node);
    let children = node.children;
    for (let i = 0; i < children.lenght; i++) {
      deepTraversal1(children[i], nodelist);
    }
  }
  return nodeList;
};
```

广度优先

```javascript
let widhtTraversal = node => {
  let nodes = [];
  let queue = [];
  if (node) {
    queue.push(node);
    while (queue.length) {
      let item = queue.shift();
      let children = item.children;
      nodes.push(item);
      for (let i = 0; i < children.length; i++) {
        queue.push(children[i]);
      }
    }
  }
  return nodes;
};
```

### 第 6 题：请分别用深度优先思想和广度优先思想实现一个拷贝函数？

简单的深度拷贝

```javascript
let cloneObject = function(source) {
  let target = {};
  for (key in source) {
    if (source.hasOwnProperty(key)) {
      let itemType = Object.prototype.toString.call(source[key]).slice(8, -1);
      switch (itemType) {
        case "Object":
          target[key] = cloneObject(source[key]);
          break;
        case "Array":
          let temp = [];
          for (let i = 0; i < source[key].length; i++) {
            temp.push(source[key][i]);
          }
          target[key] = temp;
          break;
        default:
          target[key] = source[key];
      }
    }
  }
  return target;
};
```
# 2019.08.02
## letcode 102. 二叉树的层次遍历
给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。

例如:
给定二叉树: [3,9,20,null,null,15,7],
```
    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：

[
  [3],
  [9,20],
  [15,7]
]
```

```javascript
/*
 * @lc app=leetcode id=102 lang=javascript
 *
 * [102] Binary Tree Level Order Traversal
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
  const queue = [root, null]
  const res = []
  let levelNodes  = []
  if (!root) return []
  while(queue.length > 0) {
    const t = queue.shift()
    // debugger
    if (t) {
      levelNodes.push(t.val)
      if(t.left) {
        queue.push(t.left)
      }
      if(t.right) {
        queue.push(t.right)
      }
    } else {
      res.push(levelNodes)
      levelNodes = []
      if (queue.length > 0) {
        queue.push(null) 
      }
    }
  }
  return res
};
```
## letcode 104. 二叉树的最大深度
```
给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：
给定二叉树 [3,9,20,null,null,15,7]
    3
   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 。
```

```javascript
/*
 * @lc app=leetcode id=104 lang=javascript
 *
 * [104] Maximum Depth of Binary Tree
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
  if (!root) return 0
  if ((root.left === null)&&(root.right === null)) return 1
  const queue = [root, null]
  let cur
  let deep = 1
  while((cur = queue.shift()) !== undefined) {
    if (cur === null) {
      if (queue.length === 0) return deep
      deep++
      queue.push(null)
    } else {
      let l = cur.left
      let r = cur.right
      if (l) queue.push(l)
      if (r) queue.push(r)
    }
  }
};
```
最优解
```javascript
var maxDepth = function(root) {
  if (!root) return 0
  if ((root.left === null)&&(root.right === null)) return 1
  return 1 + Math.max(maxDepth(root.left),maxDepth(root.right))
}
```
## leetcode 111. 二叉树的最小深度
```
给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明: 叶子节点是指没有子节点的节点。

示例:

给定二叉树 [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
返回它的最小深度  2.
```

```javascript
var minDepth = function(root) {
  if (!root) return 0
  if ((root.left === null)&&(root.right === null)) return 1
  const queue = [root, null]
  let cur
  let deep = 1
  while((cur = queue.shift()) !== undefined) {
    if (cur === null) {
      if (queue.length === 0) return deep
      deep++
      queue.push(null)
    } else {
      let l = cur.left
      let r = cur.right
      if (l) queue.push(l)
      if (r) queue.push(r)
      if (!l && !r) return deep
    }
  }
}
```

